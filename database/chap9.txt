エラーを防ぐため、SQL文をまとめて実行する→トランザクション

例えば、貯金と支出をまとめたものとして
UPDATE テーブル
SET 貯金 = 貯金 - 1000
SET 支出 = 支出 + 1000

としたとき、二行目と三行目の間でエラーを吐くと、二行目は実行されているため
もう一度同じコードを実行すると数が合わなくなる

そのためにトランザクションがある


トランザクションの指定

BEGIN
UPDATE テーブル
SET 貯金 = 貯金 - 1000
SET 支出 = 支出 + 1000
COMMIT

とすることで、二行目と三行目の間でエラーを吐くと、トランザクションでまとまったコードが実行される前に巻き戻り
ずれなくなる

COMMITをROLLBACKにすることで、エラーが出たときの挙動を巻き戻りを起こせる



多くのツールは一行ごとに自動でCOMMITしてくれるため、ROLLBACKで戻せない
ツールによって、実行すると、自動コミットを無くせるコマンドがある




エラーや副作用
・複数場所からの接続と、コミットのずれ
例えば、銀行で言うと
Aさん・10000円から1000円引き出す→9000円
Bさん・9000円から1000円引き出す→8000円
というとき、AさんのコミットがBさんの実行後だった場合で、AさんがROLLBACKした場合
Aさんがデータ内の10000円から1000円引き出す→データには9000円が残る
Bさんがデータ内の9000円から1000円引き出す→8000円
Aさんのコミットをキャンセル
Bさんが8000円をコミットする

となると、Aさんの-1000円は実行されてないのに、Bさんのキャンセル前で実行したデータでコミットされてしまい
結果として引き出されていることになる
コミットされてない未確定の情報を他者が使うことで、ズレが起きること
これをダーティーリードという。


・実行途中の他者の変更による矛盾
Aさんは、とある数値の合計と最大を求めたい（SELECT）
Bさんは、数値を変更したい（UPDATE）

Aさんが数値の合計を調べる→1000
Bさんが数値を変更する→どれかを1500に変更する
Aさんが数値の最大値を調べる→1500

となると、合計より最大値の方が大きいという、Aさんの実行結果に矛盾が生まれてしまう
複数のSELECT中にUPDATEしてしまい、矛盾が生まれる
これを反復不能読み取りという。


それと似た副作用に、
複数のSELECT中に、INSERTしてしまい、矛盾が生まれる
これをファントムリードという。



これらの副作用を、トランザクションを使って防ぐ

自分がコードを実行中に、他者が同じデータをいじろうとした場合、他者のコードは、自分のコードのトランザクションが終わるまで実行しない
この他者のコードを止める動作をロックという。
このロックは、動作が重くなる原因にもなる
そのため、ロックにはレベルが存在する
それを、トランザクション分離レベルという

安全性の高いものから順に、
SERIALIZABLE ロックがかかってない
REPEATABLE READ ダーティーリードが防げる
READ COMMITTED ダーティーリード、反復不能読み取りが防げる
READ UNCOMMITTED だいたい防げる

ロックのレベルを指定するコマンドは、ツールによって異なる
例：SET CURRENT ISOLATION レベル名


行や表ごとにロックをかけるコマンドもある

・排他ロック
ほかからのロックを許可しない
・共有ロック
ほかからのロックを許す

BEGIN
SELECT *
FROM テーブル名
FOR UPDATE     (NOWAIT) をつけると、すでにロックがかかっている場所をロックしようとしたら、待たずにエラーを返す
~~~~~~~~~~~
COMMIT
これで、複数のコードの実行中、最初に選択した行をロックできる

BEGIN
LOCK TABLE テーブル名 IN モード名 MODE
~~~~~~~~~~~
COMMIT
これで、複数のコードの実行中、最初に選択した表をロックできる




XをロックしてるトランザクションAがYをロックしようとする。
YをロックしてるトランザクションBがXをロックしようとする。
コレを実行すると、AはBが終わるまで待つのに対し、BもAが終わるまで追われないため
止まってしまう
これをデッドロックという

対処は、片方のトランザクションを強制的に失敗させるしか無い。
予防に、ロックの順番を揃える、トランザクションを短くするなどがある

